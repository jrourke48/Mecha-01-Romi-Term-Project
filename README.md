# Mecha-01-Romi-Term-Project
  
  Every lab and homework assignment we have completed has built upon the development of this term project. Our main objective was to assemble and program a Pololu Romi robot capable of line follwoing and autonomously navigating a predetermined course as quickly as possible. This required integrating various sensors, implementing a cascaded chassis and motor control, and creating a navigation algorithm to determine path planning and avoiding obstacle. Along the way, we applied concepts from dynamics, control theory, embedded systems, priority scheduling task oriented programming, to ensure the robot could successfully complete the challenge.

  Our group was supplied with a Romi chassis kit. Which is a differential-drive platform with a diameter of 6.5 inches and has an integrated battery holder for six AA batteries. The 2 drive wheels are located on the edge diameter of the chassis and uses 70 mm Pololu wheels that connect to Mini Plastic Gearmotors with quadrature encoders for position feedback. 2 fixed ball caster in the front and rear provides a third and 4th point of contact. The chassis also comes with a motor driver and power distribution board that powers the motors encoders and our microcontroller. We were also supplied with a nucleo board that has an stm32 MCU and a total of 76 pins to use to power, send data to sensors, and recieve data from sensors. We use Python and the micropython library to program the romi and process the data from the sensors, drive the motors, and determine romi's desired path. The Last thing we were supplied with was a BNO055 Inertial Measurement Unit. This sensor tells us our oriantation in space using an accelerometer, magnetometer, and gyroscope. The IMU processes the data recieved from these 3 sensors with in it and outputs 3 euler angles that tells our position about the x y and z axis indicated on the IMU. Since romi is driving on a flat track we are really only concerned with our angle about the z axis or our heading. In addition to what was supplied to us we also bought our own bluetooth module and infared reflection line sensors to sense the black lines drawn on the white track. Laslty, bump sensors were used to determine if romi ran into any walls or obstacles on the track. 

  The bulk of the work for the term project was not on assembly but on the design, implementation, debugging, and fine tuning of the code that allowed romi tocomplete the maze as quickly as possible without sacrificing reliability. We structure our code into 3 levels of abstraction, the highest level consists of the main file, cotask, and the taskshare. The main file runs the scheduiler that determines which task should run next. Cotask implements the scheduler and contains the data for each tasks priority and frequency. Lastly taskshare impleents the shares and queues whicha are the two data types that can be shared between classes. The middle level consists of the task, tasks are used to distrubute the main functions of all the code into more managable sections. For our project we implemented five tasks running in unison controlled by the scheduler: The nav, user, sensor, motor, and controller tasks. Each task is implemented using a finite state machine in which the total function of the task can be described by a finite number of states that transition based on flags being set or cleared. Each task has shares and hardawre objects that are passed into it the tasks then either set shares based on data recieved from the sensors or the state of the hardware object is changed based on the value of a share set in a different task. The last level consists of the classes made for each sensor, motor, and the grid that represents the task. Each of these classes consist of methods that initialize the attributes of the class and change states for a certain attribute of the class. 
  
