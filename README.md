# Mecha-01-Romi-Term-Project
  
  Every lab and homework assignment we have completed has built upon the development of this term project. Our main objective was to assemble and program a Pololu Romi robot capable of line-following and autonomously navigating a predetermined course as quickly as possible. This required integrating various sensors, implementing a cascaded chassis and motor control, and creating a navigation algorithm to determine path planning and avoiding obstacles. Along the way, we applied concepts from dynamics, control theory, embedded systems, priority scheduling task-oriented programming, to ensure the robot could complete the challenge.

  Our group was supplied with a Romi chassis kit. Which is a differential-drive platform with a diameter of 6.5 inches and has an integrated battery holder for six AA batteries. The 2 drive wheels are located on the edge diameter of the chassis and use 70 mm Pololu wheels that connect to Mini Plastic Gearmotors with quadrature encoders for position feedback. 2 fixed ball casters in the front and rear provide a third and 4th point of contact. The chassis also comes with a motor driver and power distribution board that powers the motor encoders and our microcontroller. We were also supplied with a Nucleo board that has a stm32 MCU and a total of 76 pins to use to power, send data to sensors, and receive data from sensors. We use Python and the micropython library to program the romi and process the data from the sensors, drive the motors, and determine Romi's desired path. The Last thing we were supplied with was a BNO055 Inertial Measurement Unit. This sensor tells us our orientation in space using an accelerometer, magnetometer, and gyroscope. The IMU processes the data received from these 3 sensors within it and outputs 3 Euler angles that tell our position about the x y and z axis indicated on the IMU. Since Romi is driving on a flat track we are only concerned with our angle about the z axis or our heading. In addition to what was supplied to us we also bought our own Bluetooth module and infrared reflection line sensors to sense the black lines drawn on the white track. Lastly, bump sensors were used to determine if Romi ran into any walls or obstacles on the track. 

  The bulk of the work for the term project was not on assembly but on the design, implementation, debugging, and fine-tuning of the code that allowed Romi to complete the maze as quickly as possible without sacrificing reliability. We structure our code into 3 levels of abstraction, the highest level consists of the main file, cotask, and the taskshare. The main file runs the scheduler that determines which task should run next. Cotask implements the scheduler and contains the data for the priority and frequency of each task. Lastly, taskshare implements the shares and queues which are the two data types that can be shared between classes. The middle level consists of the task, tasks are used to distribute the main functions of all the code into more manageable sections. For our project, we implemented five tasks running in unison controlled by the scheduler: The nav, user, sensor, motor, and controller tasks. Each task is implemented using a finite state machine in which the total function of the task can be described by a finite number of states that transition based on flags being set or cleared. Each task has shares and hardware objects that are passed into it the tasks then either set shares based on data received from the sensors or the state of the hardware object is changed based on the value of a share set in a different task. The last level consists of the classes made for each sensor, motor, and grid that represents the task. Each of these classes consist of methods that initialize the attributes of the class and change states for a certain attribute of the class. 

  There are 10 shares used in our term project to share information between the tasks: calibrateb, calibratew, V, L_eff, R_eff, Run, Mode, Centroid, e, and Psat. Calibrateb and w are flags used to determine when to calibrate the line array for a black-and-white background. V is the base effort input by the user. L_eff and R_eff are the actual motor efforts set based on the error determined by the line sensors or encoders. The centroid is the current center of the line reading for a range of 1 to 13 based on the center sensor channel. e is the error for the pivot and straight romi drive modes the error for the pivot mode is the difference between the desired heading based on the target and current point and the current imu yaw. While the error for straight driving is the yaw-rate value. Psat is the mean sensor value for the 13-line sensors in the array. Run is the flag that determines whether Romi should be running or not. Lastly, the mode is a share that determines the current drive mode romi is in 1 for line following, 2 for pivot, and 3 for straight.
  
